<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高度塌陷]]></title>
    <url>%2F2019%2F07%2F18%2FheightCollapse%2F</url>
    <content type="text"><![CDATA[高度塌陷什么是高度塌陷？&emsp;&emsp;在文档流中，父元素的高度默认是被子元素撑开的，但是当为子元素设置为浮动后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷，此时，父元素下的所有元素都会向上移动，这样将导致页面布局混乱。 怎么解决高度塌陷？ 将父元素的高度写死&emsp;&emsp;当父元素的高度写死后，父元素便具有固定的高度，但父元素的高度将不能自动适应子元素的高度，所以这种方案一般不推荐使用。 添加一个空白div&emsp;&emsp;可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后再对其清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用，虽然使用这种方式可以解决问题，但是会在页面中添加多余的结构。 使用伪元素&emsp;&emsp;在父元素内容的最后添加一个伪元素实现前一种方案的功能，此方法不会造成代码结构上的冗余。 开启父元素的BFC 设置元素浮动：可以撑开父元素，但是会导致父元素的宽度丢失，而且会导致下边的元素上移，容易引发布局问题； 设置元素绝对定位； 设置元素为inline-block，会导致宽度丢失； 将元素的overflow属性设置为一个非visible的值（推荐使用）； 注意：在IE6以下的浏览器不支持BFC，但有另一个隐含的属性hasLayout，作用和BFC类似，可通过开启该属性解决，推荐使用zoom：1，此样式只在IE中支持； BFC简介&emsp;&emsp;BFC（Block Formatting Context）,即块的格式化环境，根据W3C的标准，页面中的元素都有一个隐含的属性叫做BFC，该属性可以设置打开或者关闭，默认是关闭的。 开启BFC后元素会具有如下特性： 父元素的垂直外边距不会和子元素重叠； 开启BFC的元素不会被浮动元素所覆盖； 开启BFC的元素可以包含浮动的子元素；]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据双向绑定]]></title>
    <url>%2F2019%2F06%2F24%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue.js数据双向绑定 实现以下代码功能：12345678910 &lt;div id='app'&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt; var vm = new Vue(&#123; el: '#app', data: &#123; text: 'hello world' &#125;&#125;); 分成几部分实现： 输入框以及文本节点与data中的数据绑定; 输入框内容变化时，data中的数据同步变化，即view=&gt;model; data中的数据变化时，文本节点的内容同步变化,即model=&gt;view; DocumentFragment原理解析12345678910111213141516&lt;div id="app"&gt; &lt;input type="text" id="a"&gt; &lt;span id="b"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var dom = nodeToFragment(document.getElementById('app')); function nodeToFragment(node) &#123; var flag = document.createDocumentFragment(); var child; while(child = node.firstChild) &#123; flag.appendChild(child); &#125; return flag; &#125; document.getElementById('app').appendChild(dom);&lt;/script&gt; 数据初始化绑定1234567891011121314151617181920function compile(node,vm) &#123; var reg = /\&#123;\&#123;\(.*)\&#125;\&#125;/; if(node.nodeType === 1) &#123; var attr = node.attributes; for(var i = 0; i &lt; attr.length; i++) &#123; if(attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; node.value = vm.data[name]; node.removeAttribute('v-model'); &#125; &#125; &#125; if(node.nodeType === 3) &#123; if(reg.test(node.nodeValue)) &#123; var name = RegExp.$1; name = name.trim(); node.nodeValue = vm.data[name]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>vue底层原理</tag>
      </tags>
  </entry>
</search>
