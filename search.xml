<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[this浅析]]></title>
    <url>%2F2019%2F07%2F19%2Fthis%2F</url>
    <content type="text"><![CDATA[this浅析 什么是this？&emsp;&emsp;this是 JavaScript 语言的一个关键字，它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用，指代函数当前的运行环境，实际上是一个指针，指向调用函数的对象。 this的绑定规则有哪些？ 默认绑定； 隐式绑定； 显示绑定； new绑定； this绑定规则详解： 默认绑定：在没有运用其他绑定规则时，即为默认绑定，非严格模式下，this指向全局对象，严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。隐式绑定：绑定到某个对象上，形式为xxx.fun()。注意：若采用对象属性链的方式调用函数，只有最后一层会影响到调用位置，隐式绑定容易发生丢失的情况。显示绑定：通过call, apply, bind的方式，显示地指定this所指向的对象。new绑定：会创建一个新对象，并将this指向这个新的对象。 绑定优先级：&emsp;&emsp;当同时应用了多种绑定规则时，按以下优先级应用:new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定。 其他情况： 当将null或者是undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 箭头函数没有this，因此无法用call()、apply()、bind()这些方法去改变this的指向，它的this继承于外层代码库中的this。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高度塌陷]]></title>
    <url>%2F2019%2F07%2F18%2FheightCollapse%2F</url>
    <content type="text"><![CDATA[高度塌陷 什么是高度塌陷？&emsp;&emsp;在文档流中，父元素的高度默认是被子元素撑开的，但是当为子元素设置为浮动后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷，此时，父元素下的所有元素都会向上移动，这样将导致页面布局混乱。 怎么解决高度塌陷？ 将父元素的高度写死&emsp;&emsp;当父元素的高度写死后，父元素便具有固定的高度，但父元素的高度将不能自动适应子元素的高度，所以这种方案一般不推荐使用。 添加一个空白div&emsp;&emsp;可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后再对其清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用，虽然使用这种方式可以解决问题，但是会在页面中添加多余的结构。 使用伪元素&emsp;&emsp;在父元素内容的最后添加一个伪元素实现前一种方案的功能，此方法不会造成代码结构上的冗余。 开启父元素的BFC 设置元素浮动：可以撑开父元素，但是会导致父元素的宽度丢失，而且会导致下边的元素上移，容易引发布局问题； 设置元素绝对定位； 设置元素为inline-block，会导致宽度丢失； 将元素的overflow属性设置为一个非visible的值（推荐使用）； 注意：在IE6以下的浏览器不支持BFC，但有另一个隐含的属性hasLayout，作用和BFC类似，可通过开启该属性解决，推荐使用zoom：1，此样式只在IE中支持； BFC简介&emsp;&emsp;BFC（Block Formatting Context）,即块的格式化环境，根据W3C的标准，页面中的元素都有一个隐含的属性叫做BFC，该属性可以设置打开或者关闭，默认是关闭的。开启BFC后元素会具有如下特性： 父元素的垂直外边距不会和子元素重叠； 开启BFC的元素不会被浮动元素所覆盖； 开启BFC的元素可以包含浮动的子元素；]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2019%2F07%2F10%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5新特性 HTML十大新特性 语义化标签&emsp;&emsp;语义化标签使页面的内容结构化，易理解； 增强型表单&emsp;&emsp;提供了多种新的表单输入类型以及一些表单元素和表单属性，可以更好的对输入内容进行控制和验证； 视频和音频&emsp;&emsp;使用&lt;video&gt;元素提供播放视频文件的标准，使用&lt;audio&gt;元素提供播放音频文件的标准； Canvas绘图&emsp;&emsp;使用JavaScript绘制图像，通过&lt;canvas&gt;元素呈现； SVG绘图&emsp;&emsp;使用XML进行绘图，每个被绘制的图形均被视为对象； 地理定位&emsp;&emsp;Geolocation用于定位用户的位置； 拖放API Web Worker&emsp;&emsp;当在HTML页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。而web worker是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。 Web Storage&emsp;&emsp;Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。主要目的是提供一种在cookie之外存储会话数据的途径和一种存储大量可以跨会话存在的数据的机制。&emsp;&emsp;Web Storage分为两种：sessionStorage 和localStorage ，sessionStorage将数据保存在session中，浏览器关闭即消失，而localStorage则一直将数据保存在客户端本地。 WebSocket&emsp;&emsp;WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据双向绑定]]></title>
    <url>%2F2019%2F06%2F24%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue.js数据双向绑定 实现以下代码功能：12345678910 &lt;div id='app'&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt; var vm = new Vue(&#123; el: '#app', data: &#123; text: 'hello world' &#125;&#125;); 分成几部分实现： 输入框以及文本节点与data中的数据绑定; 输入框内容变化时，data中的数据同步变化，即view=&gt;model; data中的数据变化时，文本节点的内容同步变化,即model=&gt;view; DocumentFragment原理解析12345678910111213141516&lt;div id="app"&gt; &lt;input type="text" id="a"&gt; &lt;span id="b"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var dom = nodeToFragment(document.getElementById('app')); function nodeToFragment(node) &#123; var flag = document.createDocumentFragment(); var child; while(child = node.firstChild) &#123; flag.appendChild(child); &#125; return flag; &#125; document.getElementById('app').appendChild(dom);&lt;/script&gt; 数据初始化绑定1234567891011121314151617181920function compile(node,vm) &#123; var reg = /\&#123;\&#123;\(.*)\&#125;\&#125;/; if(node.nodeType === 1) &#123; var attr = node.attributes; for(var i = 0; i &lt; attr.length; i++) &#123; if(attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; node.value = vm.data[name]; node.removeAttribute('v-model'); &#125; &#125; &#125; if(node.nodeType === 3) &#123; if(reg.test(node.nodeValue)) &#123; var name = RegExp.$1; name = name.trim(); node.nodeValue = vm.data[name]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>vue底层原理</tag>
      </tags>
  </entry>
</search>
