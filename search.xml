<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Http简介]]></title>
    <url>%2F2019%2F07%2F26%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP（超文本传输协议） HTTP协议的主要特点 简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象，传输的类型由Content-Type加以标记。 无连接：HTTP使用了TCP连接，通信的双方在交换HTTP报文之前不需要先建立HTTP连接。 无状态：对于同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同，服务器不保留与客户端连接时的任何状态，这种无状态特性简化了服务器的设计。 HTTP协议的工作流程 客户端与服务器建立连接； 客户端向服务器发送请求； 服务器接接收请求，返回相应的响应报文； 客户端与服务器关闭连接； HTTP的URL 对于万维网的网点的访问要使用HTTP协议，通过URL去定位资源的位置。 HTTP的URL一般形式是：http://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; HTTP的默认端口号是80，通常可以省略，URL中的字母不区分大小写。 HTTP报文结构&emsp;&emsp;HTTP有两类报文，请求报文和响应报文，都是由三个部分组成，区别在于开始行不同。开始行：用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行叫做状态行。开始行由三个字段组成，之间以空格分隔开。首部行：用来说明浏览器、服务器或报文主体的一些信息。整个首部行结束时，还有一个空行将首部行和后面的实体主体分开。实体主体：一般不使用此字段。请求报文：请求报文的请求行有三个内容，即方法、请求资源的URL和HTTP的版本。请求方法： GET：请求读取由URL所标志的信息； POST：给服务器添加信息； HEAD：请求读取由URL所标志的信息的首部； PUT：在指明的URL下存储一个稳定； DELETE：删除指明的URL所标志的资源； TRACE：用来进行环回测试的请求报文； CONNECT：用于代理服务器； OPTION：请求一些选项的信息；一个完整的HTTP请求报文示例：GET /dir/index.html HTTP/1.1&emsp;&emsp;开始行：使用了相对URLHost: www.xyz.edu.cn&emsp;&emsp;（首部行开始）给出了主机的域名Connection: close&emsp;&emsp;告诉浏览器发送完请求的文档后就可以释放连接User-Agent: Mozilla/5.0&emsp;&emsp;表明用户代理使用的是 FirefoxAccept-Language: cn&emsp;&emsp;表示用户希望优先得到中文版本的文档（首部行结束）（空行） 响应报文：响应报文的状态行有三个内容，即HTTP版本、状态码以及解释状态码的简单短语。状态码：状态码都是三位数的，分为5大类，分别以数字1~5开头。 1xx：表示通知信息，如收到请求或正在进行处理。 2xx：表示成功，如接受或知道了。 3xx：表示重定向，如要完成请求须采取进一步的行动。 4xx：表示客户端出错，如请求中有错误的语法或不能完成。 5xx：表示服务器差错，如服务器失效无法完成请求。 一个响应报文示例：HTTP/1.1 202 Accepted HTTP持久连接（从HTTP1.1开始支持）非持久连接：HTTP协议采用“请求–应答”模式，当使用普通模式，即非Keep-Alive（持久连接）模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；持久连接：当使用Keep-Alive模式（持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了重新建立连接。 Get与Post区别Get和Post是Http协议中的两种发送请求的方法，而Http是基于TCP/IP的关于数据如何在万维网中通信的协议，Get和Post本质上就是TCP连接，并无差别。 Get在浏览器回退时是无害的，而Post会再次提交请求； Get产生的URL地址可以被Bookmark，而Post不可以； Get请求会被浏览器主动cache，而Post不会； Get请求只能进行url编码，而Post支持多种编码方式； Get请求参数会被完整保留在浏览器历史记录中，而Post中的参数不会被保留； Get请求在URL中传送的参数是有长度限制的，而Post没有； 对参数的数据类型，Get只接受ASCII字符，而Post没有限制； Get比Post更不安全，参数直接暴露在URL上，不能用来传递敏感信息； Get参数通过URL传递，Post放在Request body中； Get产生一个TCP数据包，Post产生两个TCP数据包。对于Get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于Post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）； HTTP请求头内容 使用的HTTP动作：post/get； 浏览器所能接受的Content-type：Accept； 浏览器所能接受的语言和编码信息Accept-language，Accept-Encoding； 本机信息：浏览器类型、操作系统类型User-Agent； 请求的主机和端口Host； 使用的连接方式Connnection； Http/1.1 ，1.1为协议的版本，使用持久连接，1.0使用非持久连接； Cookie；]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this浅析]]></title>
    <url>%2F2019%2F07%2F19%2Fthis%2F</url>
    <content type="text"><![CDATA[this浅析 什么是this？&emsp;&emsp;this是 JavaScript 语言的一个关键字，它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用，指代函数当前的运行环境，实际上是一个指针，指向调用函数的对象。 this的绑定规则有哪些？ 默认绑定； 隐式绑定； 显示绑定； new绑定； this绑定规则详解：默认绑定：在没有运用其他绑定规则时，即为默认绑定，非严格模式下，this指向全局对象，严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。隐式绑定：绑定到某个对象上，形式为xxx.fun()。注意：若采用对象属性链的方式调用函数，只有最后一层会影响到调用位置，隐式绑定容易发生丢失的情况。显示绑定：通过call, apply, bind的方式，显示地指定this所指向的对象。new绑定：会创建一个新对象，并将this指向这个新的对象。 绑定优先级：&emsp;&emsp;当同时应用了多种绑定规则时，按以下优先级应用:new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定。 其他情况： 当将null或者是undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 箭头函数没有this，因此无法用call()、apply()、bind()这些方法去改变this的指向，它的this继承于外层代码库中的this。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度塌陷]]></title>
    <url>%2F2019%2F07%2F18%2FheightCollapse%2F</url>
    <content type="text"><![CDATA[高度塌陷 什么是高度塌陷？&emsp;&emsp;在文档流中，父元素的高度默认是被子元素撑开的，但是当为子元素设置为浮动后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷，此时，父元素下的所有元素都会向上移动，这样将导致页面布局混乱。 怎么解决高度塌陷？ 将父元素的高度写死&emsp;&emsp;当父元素的高度写死后，父元素便具有固定的高度，但父元素的高度将不能自动适应子元素的高度，所以这种方案一般不推荐使用。 添加一个空白div&emsp;&emsp;可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后再对其清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用，虽然使用这种方式可以解决问题，但是会在页面中添加多余的结构。 使用伪元素&emsp;&emsp;在父元素内容的最后添加一个伪元素实现前一种方案的功能，此方法不会造成代码结构上的冗余。 开启父元素的BFC 设置元素浮动：可以撑开父元素，但是会导致父元素的宽度丢失，而且会导致下边的元素上移，容易引发布局问题； 设置元素绝对定位； 设置元素为inline-block，会导致宽度丢失； 将元素的overflow属性设置为一个非visible的值（推荐使用）； 注意：在IE6以下的浏览器不支持BFC，但有另一个隐含的属性hasLayout，作用和BFC类似，可通过开启该属性解决，推荐使用zoom：1，此样式只在IE中支持； BFC简介&emsp;&emsp;BFC（Block Formatting Context）,即块的格式化环境，根据W3C的标准，页面中的元素都有一个隐含的属性叫做BFC，该属性可以设置打开或者关闭，默认是关闭的。开启BFC后元素会具有如下特性： 父元素的垂直外边距不会和子元素重叠； 开启BFC的元素不会被浮动元素所覆盖； 开启BFC的元素可以包含浮动的子元素；]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2019%2F07%2F10%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5新特性 HTML十大新特性 语义化标签&emsp;&emsp;语义化标签使页面的内容结构化，易理解； 增强型表单&emsp;&emsp;提供了多种新的表单输入类型以及一些表单元素和表单属性，可以更好的对输入内容进行控制和验证； 视频和音频&emsp;&emsp;使用&lt;video&gt;元素提供播放视频文件的标准，使用&lt;audio&gt;元素提供播放音频文件的标准； Canvas绘图&emsp;&emsp;使用JavaScript绘制图像，通过&lt;canvas&gt;元素呈现； SVG绘图&emsp;&emsp;使用XML进行绘图，每个被绘制的图形均被视为对象； 地理定位&emsp;&emsp;Geolocation用于定位用户的位置； 拖放API Web Worker&emsp;&emsp;当在HTML页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。而web worker是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。 Web Storage&emsp;&emsp;Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。主要目的是提供一种在cookie之外存储会话数据的途径和一种存储大量可以跨会话存在的数据的机制。&emsp;&emsp;Web Storage分为两种：sessionStorage 和localStorage ，sessionStorage将数据保存在session中，浏览器关闭即消失，而localStorage则一直将数据保存在客户端本地。 WebSocket&emsp;&emsp;WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型及判断]]></title>
    <url>%2F2019%2F06%2F30%2Fvariable%2F</url>
    <content type="text"><![CDATA[JavaScript数据类型及判断 JS数据类型&emsp;&emsp;六大基本数据类型：NULL, Undefined, Boolean, String, Number, Symbol（ES6新增）。&emsp;&emsp;三大引用类型：Object, Array, Function。 JS变量类型判断let num = 123; let str = &apos;abc&apos;; let bool = true; let arr = [1,2,3]; let json = {&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 25}; let und = undefined; let nul = null; let date = new Date(); let reg = /^[a-z]$/; let error = new Error(); let fun = console.log; let sym = Symbol(&apos;foo&apos;); 使用typeof检测&emsp;&emsp;typeof只能检测出string, number, boolean, function, undefined，其他类型的数据检测结果均为object，不能区分。 typeof num =&gt; &quot;number&quot; typeof str =&gt; &quot;string&quot; typeof boolean =&gt; &quot;boolean&quot; typeof arr =&gt; &quot;object&quot; typeof json =&gt; &quot;object&quot; typeof und =&gt; &quot;undefined&quot; typeof nul =&gt; &quot;object&quot; typeof date =&gt; &quot;object&quot; typeof reg =&gt; &quot;object&quot; typeof error =&gt; &quot;object&quot; typeof fun =&gt; &quot;function&quot; typeof sym =&gt; &quot;symbol&quot; 使用instanceof检测&emsp;&emsp;通过判断参照对象的prototype属性所指向的对象是否在被检测对象的原型链上进行检测，此方法对null和undefined检测为object，因为js中没有这种全局类型，另外，此方法有一个弊端，对于number, string, boolean这三种类型，只有通过构造函数定义的才能被检测出，如let num = new Number(1)，而这种let num = 1则不能被检测出。 num instanceof Number =&gt; false str instanceof String =&gt; false bool instanceof Boolean =&gt; false arr instanceof Array =&gt; true json instanceof Object =&gt; true und instanceof Object =&gt; false nul instaceof Object =&gt; false date instanceof Object =&gt; true reg instanceof Object =&gt; true error instanceof Object =&gt; true fun instanceof Function =&gt; true sym instanceof Symbol =&gt; false 使用constructor检测&emsp;&emsp;constructor是原型对象的属性指向构造函数，这种方式解决了instanceof的弊端，但对于undefined和null仍有缺陷，而且constructor指向的构造函数是可以被修改的。 num.constructor == Number =&gt; true str.constructor == String =&gt; true bool.constructor == Boolean =&gt; true arr.constructor == Array =&gt; true json.constructor == Object =&gt; true und.constructor == Undefined =&gt; true unl.constructor == Null =&gt; true date.constructor == Date =&gt; true reg.constructor == RegExp =&gt; true error.constructor == Error =&gt; true fun.constructor == Function =&gt; true sym.constructor == Symbol =&gt; true 使用Object.prototype.toString.call检测&emsp;&emsp;通过取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于“[object Array]“的字符串作为结果（[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较即可，此方法可以检测出所有的变量类型。 Object.prototype.toString.call(num) =&gt; &quot;[object Number]&quot; Object.prototype.toString.call(str) =&gt; &quot;[object String]&quot; Object.prototype.toString.call(bool) =&gt; &quot;[object Boolean]&quot; Object.prototype.toString.call(arr) =&gt; &quot;[object Array]&quot; Object.prototype.toString.call(json) =&gt; &quot;[object Object]&quot; Object.prototype.toString.call(nul) =&gt; &quot;[object Null]&quot; Object.prototype.toString.call(und) =&gt; &quot;[object Undefined]&quot; Object.prototype.toString.call(date) =&gt; &quot;[object Date]&quot; Object.prototype.toString.call(reg) =&gt; &quot;[object RegExp]&quot; Object.prototype.toString.call(error) =&gt; &quot;[object Error]&quot; Object.prototype.toString.call(fun) =&gt; &quot;[object Function]&quot; Object.prototype.toString.call(sym) =&gt; &quot;[object Symbol]&quot; 使用jquery中的$.type检测&emsp;&emsp;此方法是基于ES5的Object.prototype.toString.call进一步封装，可以检测出所有的变量类型。 $.type(num) =&gt; &quot;number&quot; $.type(str) =&gt; &quot;string&quot; $.type(bool) =&gt; &quot;boolean&quot; $.type(arr) =&gt; &quot;array&quot; $.type(json) =&gt; &quot;object&quot; $.type(und) =&gt; &quot;undefined&quot; $.type(nul) =&gt; &quot;null&quot; $.type(date) =&gt; &quot;date&quot; $.type(reg) =&gt; &quot;regexp&quot; $.type(error) =&gt; &quot;error&quot; $.type(fun) =&gt; &quot;function&quot; $.type(sym) =&gt; &quot;symbol&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据双向绑定]]></title>
    <url>%2F2019%2F06%2F24%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue.js数据双向绑定 实现以下代码功能：12345678910 &lt;div id='app'&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt; var vm = new Vue(&#123; el: '#app', data: &#123; text: 'hello world' &#125;&#125;); 分成几部分实现： 输入框以及文本节点与data中的数据绑定; 输入框内容变化时，data中的数据同步变化，即view=&gt;model; data中的数据变化时，文本节点的内容同步变化,即model=&gt;view; DocumentFragment原理解析12345678910111213141516&lt;div id="app"&gt; &lt;input type="text" id="a"&gt; &lt;span id="b"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var dom = nodeToFragment(document.getElementById('app')); function nodeToFragment(node) &#123; var flag = document.createDocumentFragment(); var child; while(child = node.firstChild) &#123; flag.appendChild(child); &#125; return flag; &#125; document.getElementById('app').appendChild(dom);&lt;/script&gt; 数据初始化绑定1234567891011121314151617181920function compile(node,vm) &#123; var reg = /\&#123;\&#123;\(.*)\&#125;\&#125;/; if(node.nodeType === 1) &#123; var attr = node.attributes; for(var i = 0; i &lt; attr.length; i++) &#123; if(attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; node.value = vm.data[name]; node.removeAttribute('v-model'); &#125; &#125; &#125; if(node.nodeType === 3) &#123; if(reg.test(node.nodeValue)) &#123; var name = RegExp.$1; name = name.trim(); node.nodeValue = vm.data[name]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>vue底层原理</tag>
      </tags>
  </entry>
</search>
